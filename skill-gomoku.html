<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>ÊäÄËÉΩ‰∫îÂ≠êÊ£ã ‚Äî Skill Gomoku</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
@font-face{font-family:'GameFont';src:local('Arial Black'),local('Impact'),local('sans-serif')}
:root{--bg:#1a1a2e;--panel:#16213e;--accent:#e94560;--gold:#f5c518;--cyan:#00d2ff;--green:#0f0;--board-bg:#dcb35c;--board-dark:#c9a84c;--line:#222}
body{font-family:'GameFont','Arial Black',Impact,sans-serif;background:var(--bg);color:#fff;min-height:100vh;display:flex;flex-direction:column;align-items:center;overflow-x:hidden;user-select:none}
#title-screen{position:fixed;inset:0;z-index:1000;background:linear-gradient(135deg,#1a1a2e,#16213e,#0f3460);display:flex;flex-direction:column;align-items:center;justify-content:center;transition:opacity .8s}
#title-screen.hidden{opacity:0;pointer-events:none}
#title-screen h1{font-size:clamp(2rem,6vw,4rem);color:var(--gold);text-shadow:0 0 20px var(--gold),0 0 40px var(--accent);margin-bottom:.5rem;animation:pulse 1.5s infinite}
#title-screen .subtitle{font-size:clamp(.9rem,2.5vw,1.4rem);color:var(--cyan);margin-bottom:1.5rem;text-align:center;max-width:90vw}
.lyrics{font-size:clamp(.7rem,2vw,1rem);color:#ffd700;text-align:center;max-width:600px;line-height:1.8;margin-bottom:2rem;opacity:.9}
.lyrics .zh{font-size:clamp(.8rem,2.2vw,1.1rem);color:var(--accent)}
#start-btn{font-size:1.5rem;padding:15px 50px;background:linear-gradient(45deg,var(--accent),#ff6b6b);border:none;border-radius:50px;color:#fff;cursor:pointer;font-family:inherit;animation:bounce 1s infinite;box-shadow:0 0 30px rgba(233,69,96,.5)}
#start-btn:hover{transform:scale(1.1);box-shadow:0 0 50px rgba(233,69,96,.8)}
.avatar-container{display:flex;gap:20px;margin-bottom:1.5rem}
.avatar{width:80px;height:80px}
#game-container{display:none;flex-direction:column;align-items:center;padding:10px;width:100%;max-width:700px}
#game-container.active{display:flex}
#header{text-align:center;margin-bottom:8px;width:100%}
#header h1{font-size:clamp(1.2rem,4vw,2rem);color:var(--gold);text-shadow:0 0 10px var(--gold)}
#turn-indicator{font-size:clamp(1rem,3vw,1.5rem);padding:8px 20px;border-radius:25px;margin:5px 0;display:inline-block;transition:all .3s}
#turn-indicator.black{background:rgba(0,0,0,.6);border:2px solid #555}
#turn-indicator.white{background:rgba(255,255,255,.2);border:2px solid #fff}
#score-bar{display:flex;justify-content:center;gap:30px;font-size:clamp(.8rem,2vw,1.1rem);margin:5px 0}
.score-item{display:flex;align-items:center;gap:6px}
.score-dot{width:16px;height:16px;border-radius:50%;display:inline-block;border:2px solid #555}
.score-dot.b{background:#111}
.score-dot.w{background:#eee;width:14px;height:14px;border-radius:2px}
#canvas-wrap{position:relative;width:100%;max-width:600px;aspect-ratio:1;margin:5px auto}
canvas{width:100%;height:100%;border-radius:8px;cursor:pointer;touch-action:none}
#skill-panel{display:flex;flex-wrap:wrap;justify-content:center;gap:8px;margin:10px 0;width:100%}
.skill-btn{padding:8px 14px;border:2px solid #444;border-radius:12px;background:var(--panel);color:#999;font-family:inherit;font-size:clamp(.65rem,1.8vw,.85rem);cursor:not-allowed;transition:all .3s;position:relative;overflow:hidden;min-width:120px;text-align:center}
.skill-btn.ready{border-color:var(--cyan);color:#fff;cursor:pointer;animation:glow 2s infinite}
.skill-btn.ready:hover{transform:translateY(-3px);box-shadow:0 5px 20px rgba(0,210,255,.4)}
.skill-btn.used{opacity:.4;text-decoration:line-through}
.skill-btn .zh{display:block;font-size:clamp(.8rem,2vw,1.1rem);font-weight:bold}
.skill-btn .en{display:block;font-size:.65rem;opacity:.7}
#controls{display:flex;gap:10px;margin:8px 0}
#controls button{padding:8px 20px;border:2px solid var(--accent);border-radius:20px;background:transparent;color:var(--accent);font-family:inherit;font-size:.9rem;cursor:pointer;transition:all .3s}
#controls button:hover{background:var(--accent);color:#fff}
#overlay{position:fixed;inset:0;z-index:500;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.7)}
#overlay.active{display:flex}
#overlay-content{text-align:center;animation:popIn .5s}
#overlay h2{font-size:clamp(2rem,6vw,3.5rem);margin-bottom:10px}
#overlay p{font-size:1.2rem;margin-bottom:20px}
#overlay button{padding:10px 30px;font-size:1.1rem;border:2px solid var(--gold);border-radius:25px;background:transparent;color:var(--gold);cursor:pointer;font-family:inherit;margin:5px}
#overlay button:hover{background:var(--gold);color:#000}
#skill-overlay{position:fixed;inset:0;z-index:600;display:none;align-items:center;justify-content:center;pointer-events:none}
#skill-overlay.active{display:flex}
#skill-text{font-size:clamp(2.5rem,8vw,5rem);font-weight:bold;text-shadow:0 0 30px currentColor,0 0 60px currentColor;animation:skillFlash 1.5s forwards}
#freeze-indicator{position:absolute;font-size:.7rem;color:var(--cyan);pointer-events:none}
#particles{position:fixed;inset:0;pointer-events:none;z-index:550}
#mute-btn{position:fixed;top:10px;right:10px;z-index:900;background:rgba(0,0,0,.5);border:1px solid #555;color:#fff;padding:6px 12px;border-radius:15px;cursor:pointer;font-size:.8rem}
#share-btn{display:none}
@keyframes pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.05)}}
@keyframes bounce{0%,100%{transform:translateY(0)}50%{transform:translateY(-8px)}}
@keyframes glow{0%,100%{box-shadow:0 0 5px rgba(0,210,255,.3)}50%{box-shadow:0 0 20px rgba(0,210,255,.6)}}
@keyframes popIn{from{transform:scale(0);opacity:0}to{transform:scale(1);opacity:1}}
@keyframes skillFlash{0%{transform:scale(0) rotate(-20deg);opacity:0}30%{transform:scale(1.3) rotate(5deg);opacity:1}60%{transform:scale(1) rotate(0deg)}100%{transform:scale(1.1);opacity:0}}
@keyframes shake{0%,100%{transform:translate(0)}10%{transform:translate(-8px,6px)}20%{transform:translate(8px,-6px)}30%{transform:translate(-6px,8px)}40%{transform:translate(6px,-8px)}50%{transform:translate(-8px,-6px)}60%{transform:translate(8px,6px)}70%{transform:translate(-6px,-8px)}80%{transform:translate(6px,8px)}90%{transform:translate(-8px,6px)}}
@keyframes confetti-fall{0%{transform:translateY(-10vh) rotate(0deg);opacity:1}100%{transform:translateY(110vh) rotate(720deg);opacity:0}}
@keyframes ripple{0%{transform:scale(0);opacity:.6}100%{transform:scale(3);opacity:0}}
@keyframes victory-dance{0%{transform:rotate(0deg) scale(1)}25%{transform:rotate(10deg) scale(1.1)}50%{transform:rotate(-10deg) scale(1)}75%{transform:rotate(10deg) scale(1.1)}100%{transform:rotate(0deg) scale(1)}}
.confetti{position:fixed;width:10px;height:10px;top:-10px;z-index:700;animation:confetti-fall 3s linear forwards}
@media(max-width:500px){
  .skill-btn{min-width:100px;padding:6px 10px}
  #score-bar{gap:15px}
}
</style>
</head>
<body>

<button id="mute-btn" onclick="toggleMute()">Sound: ON</button>

<!-- TITLE SCREEN -->
<div id="title-screen">
  <div class="avatar-container">
    <svg class="avatar" viewBox="0 0 80 80">
      <circle cx="40" cy="28" r="18" fill="#ffd700" stroke="#333" stroke-width="2"/>
      <circle cx="33" cy="25" r="3" fill="#333"/><circle cx="47" cy="25" r="3" fill="#333"/>
      <path d="M32 33 Q40 40 48 33" stroke="#333" stroke-width="2" fill="none"/>
      <rect x="25" y="46" width="30" height="28" rx="5" fill="#e94560"/>
      <line x1="30" y1="46" x2="20" y2="35" stroke="#ffd700" stroke-width="3" stroke-linecap="round"/>
      <line x1="50" y1="46" x2="60" y2="30" stroke="#ffd700" stroke-width="3" stroke-linecap="round"/>
      <rect x="25" y="74" width="12" height="6" rx="2" fill="#333"/>
      <rect x="43" y="74" width="12" height="6" rx="2" fill="#333"/>
      <ellipse cx="40" cy="12" rx="20" ry="8" fill="none" stroke="#ffd700" stroke-width="2"/>
      <text x="40" y="15" text-anchor="middle" font-size="8" fill="#333">SKILL</text>
    </svg>
    <svg class="avatar" viewBox="0 0 80 80">
      <circle cx="40" cy="28" r="18" fill="#00d2ff" stroke="#333" stroke-width="2"/>
      <circle cx="33" cy="25" r="3" fill="#333"/><circle cx="47" cy="25" r="3" fill="#333"/>
      <path d="M34 35 Q40 30 46 35" stroke="#333" stroke-width="2" fill="none"/>
      <rect x="25" y="46" width="30" height="28" rx="5" fill="#16213e"/>
      <line x1="30" y1="50" x2="15" y2="55" stroke="#00d2ff" stroke-width="3" stroke-linecap="round"/>
      <line x1="50" y1="50" x2="65" y2="55" stroke="#00d2ff" stroke-width="3" stroke-linecap="round"/>
      <rect x="25" y="74" width="12" height="6" rx="2" fill="#333"/>
      <rect x="43" y="74" width="12" height="6" rx="2" fill="#333"/>
      <polygon points="30,10 40,2 50,10" fill="#00d2ff" stroke="#333" stroke-width="1"/>
    </svg>
  </div>
  <h1>ÊäÄËÉΩ‰∫îÂ≠êÊ£ã</h1>
  <div class="subtitle">SKILL GOMOKU</div>
  <div class="lyrics">
    <div class="zh">ÊôÆÈÄö‰∫îÂ≠êÊ£ãÂ∞±ÊòØ‰∫î‰∏™Ê£ãÂ≠êËøûÊàê‰∏ÄÊù°Á∫ø Â§öÊó†ËÅäÂïä</div>
    <div>Traditional Gomoku is putting five pieces in a line ‚Äî so boring!</div>
    <br>
    <div class="zh">‰ΩÜÊòØÊäÄËÉΩ‰∫îÂ≠êÊ£ãÂä†‰∏ä‰∫ÜÊäÄËÉΩ Â§öÂ•ΩÁé©Âïä Ë¶ÅÁàÜÁÇ∏</div>
    <div>But Skill Gomoku adds skills ‚Äî so fun! Gonna explode!</div>
  </div>
  <button id="start-btn" onclick="startGame()">ÂºÄÂßãÊ∏∏Êàè START</button>
</div>

<!-- GAME -->
<div id="game-container">
  <div id="header">
    <h1>ÊäÄËÉΩ‰∫îÂ≠êÊ£ã Skill Gomoku</h1>
    <div id="turn-indicator" class="black">Black's Turn ‚óè</div>
    <div id="score-bar">
      <span class="score-item"><span class="score-dot b"></span> Black: <span id="black-score">0</span></span>
      <span class="score-item"><span class="score-dot w"></span> White: <span id="white-score">0</span></span>
    </div>
  </div>
  <div id="canvas-wrap">
    <canvas id="board"></canvas>
  </div>
  <div id="skill-panel">
    <button class="skill-btn" id="skill-0" onclick="activateSkill(0)"><span class="zh">È£ûÊ≤ôËµ∞Áü≥</span><span class="en">Flying Sand & Stones</span></button>
    <button class="skill-btn" id="skill-1" onclick="activateSkill(1)"><span class="zh">ÂäõÊãîÂ±±ÂÖÆ</span><span class="en">Mountain Flip</span></button>
    <button class="skill-btn" id="skill-2" onclick="activateSkill(2)"><span class="zh">ÈùôÂ¶ÇÊ≠¢Ê∞¥</span><span class="en">Still Water</span></button>
    <button class="skill-btn" id="skill-3" onclick="activateSkill(3)"><span class="zh">Êó∂ÂÖâÂÄíÊµÅ</span><span class="en">Time Reversal</span></button>
  </div>
  <div id="controls">
    <button onclick="restartGame()">Restart</button>
    <button id="share-btn" onclick="shareScore()">Share #SkillGomoku</button>
  </div>
</div>

<!-- OVERLAYS -->
<div id="overlay"><div id="overlay-content"></div></div>
<div id="skill-overlay"><div id="skill-text"></div></div>
<canvas id="particles"></canvas>

<script>
// ============================================================
// SKILL GOMOKU ‚Äî Complete Game Engine
// ============================================================

const SIZE = 15;
const EMPTY = 0, BLACK = 1, WHITE = 2;

// --- State ---
let board = [];
let currentPlayer = BLACK;
let gameOver = false;
let moveHistory = [];        // [{r, c, player}, ...]
let scores = {1: 0, 2: 0};
let skillUsed = {1: [false,false,false,false], 2: [false,false,false,false]};
let activeSkill = -1;        // which skill is being executed
let skillPhase = '';          // sub-phase for multi-step skills
let removesLeft = 0;          // for Flying Sand
let freezeZones = [];         // [{r,c,turnsLeft}]
let frozen = [];              // 2D boolean array for frozen cells
let muted = false;
let audioCtx = null;
let titleMelodyInterval = null;
let canvasEl, ctx, pCanvas, pCtx;
let cellSize, boardPixels, padding;
let hoverR = -1, hoverC = -1;
let animating = false;

// ============================================================
// AUDIO ‚Äî Web Audio API chiptune & sound effects
// ============================================================
function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

function playTone(freq, duration, type='sine', vol=0.12) {
  if (muted || !audioCtx) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type;
  o.frequency.value = freq;
  g.gain.setValueAtTime(vol, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime + duration);
}

function playPlace() { playTone(600, 0.08, 'sine', 0.15); }
function playWin() {
  [523,659,784,1047].forEach((f,i) => setTimeout(() => playTone(f, 0.3, 'square', 0.1), i*150));
}
function playSkillSound() {
  [300,400,500,600,800,1000].forEach((f,i) => setTimeout(() => playTone(f, 0.15, 'sawtooth', 0.08), i*60));
}

// Meme melody ‚Äî simple catchy loop
const melodyNotes = [
  [523,200],[587,200],[659,200],[784,400],[659,200],[523,200],[587,400],
  [523,200],[440,200],[392,200],[440,400],[523,200],[587,200],[523,400],
  [659,200],[784,200],[880,200],[784,400],[659,200],[523,200],[587,600]
];
function playTitleMelody() {
  if (muted || !audioCtx) return;
  let t = 0;
  melodyNotes.forEach(([freq, dur]) => {
    setTimeout(() => { if (!muted && audioCtx) playTone(freq, dur/1000*1.2, 'square', 0.06); }, t);
    t += dur;
  });
  titleMelodyInterval = setTimeout(playTitleMelody, t + 400);
}
function stopTitleMelody() { clearTimeout(titleMelodyInterval); }

function toggleMute() {
  muted = !muted;
  document.getElementById('mute-btn').textContent = muted ? 'Sound: OFF' : 'Sound: ON';
  if (muted) stopTitleMelody();
}

// ============================================================
// SPEECH ‚Äî SpeechSynthesis for skill chanting
// ============================================================
function chant(text) {
  if (muted || !window.speechSynthesis) return;
  const u = new SpeechSynthesisUtterance(text);
  u.lang = 'zh-CN'; u.rate = 0.9; u.pitch = 1.2;
  window.speechSynthesis.speak(u);
}

// ============================================================
// BOARD ‚Äî Init, draw, resize
// ============================================================
function initBoard() {
  board = Array.from({length: SIZE}, () => Array(SIZE).fill(EMPTY));
  frozen = Array.from({length: SIZE}, () => Array(SIZE).fill(false));
  freezeZones = [];
  moveHistory = [];
  currentPlayer = BLACK;
  gameOver = false;
  activeSkill = -1;
  skillPhase = '';
  removesLeft = 0;
  animating = false;
}

function resetSkills() {
  skillUsed = {1: [false,false,false,false], 2: [false,false,false,false]};
}

function setupCanvas() {
  canvasEl = document.getElementById('board');
  ctx = canvasEl.getContext('2d');
  pCanvas = document.getElementById('particles');
  pCtx = pCanvas.getContext('2d');
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);
}

function resizeCanvas() {
  const wrap = document.getElementById('canvas-wrap');
  const w = Math.max(400, Math.min(wrap.clientWidth, 600));
  canvasEl.width = w * (window.devicePixelRatio || 1);
  canvasEl.height = w * (window.devicePixelRatio || 1);
  canvasEl.style.width = w + 'px';
  canvasEl.style.height = w + 'px';
  pCanvas.width = window.innerWidth;
  pCanvas.height = window.innerHeight;
  boardPixels = w * (window.devicePixelRatio || 1);
  padding = boardPixels * 0.05;
  cellSize = (boardPixels - 2 * padding) / (SIZE - 1);
  drawBoard();
}

function gridToPixel(row, col) {
  return { x: padding + col * cellSize, y: padding + row * cellSize };
}

function pixelToGrid(px, py) {
  const ratio = window.devicePixelRatio || 1;
  const col = Math.round((px * ratio - padding) / cellSize);
  const row = Math.round((py * ratio - padding) / cellSize);
  if (row < 0 || row >= SIZE || col < 0 || col >= SIZE) return null;
  return {r: row, c: col};
}

function drawBoard() {
  const w = boardPixels;
  // Background
  ctx.fillStyle = '#dcb35c';
  ctx.fillRect(0, 0, w, w);
  // Alternating cells
  for (let r = 0; r < SIZE - 1; r++) {
    for (let c = 0; c < SIZE - 1; c++) {
      const {x, y} = gridToPixel(r, c);
      ctx.fillStyle = (r + c) % 2 === 0 ? '#dcb35c' : '#c9a84c';
      ctx.fillRect(x, y, cellSize, cellSize);
    }
  }
  // Grid lines
  ctx.strokeStyle = '#222';
  ctx.lineWidth = Math.max(1, boardPixels / 600);
  for (let i = 0; i < SIZE; i++) {
    const {x: x0, y: y0} = gridToPixel(i, 0);
    const {x: x1, y: y1} = gridToPixel(i, SIZE - 1);
    ctx.beginPath(); ctx.moveTo(x0, y0); ctx.lineTo(x1, y1); ctx.stroke();
    const {x: cx0, y: cy0} = gridToPixel(0, i);
    const {x: cx1, y: cy1} = gridToPixel(SIZE - 1, i);
    ctx.beginPath(); ctx.moveTo(cx0, cy0); ctx.lineTo(cx1, cy1); ctx.stroke();
  }
  // Star points
  const stars = [[3,3],[3,7],[3,11],[7,3],[7,7],[7,11],[11,3],[11,7],[11,11]];
  stars.forEach(([r,c]) => {
    const {x, y} = gridToPixel(r, c);
    ctx.beginPath(); ctx.arc(x, y, cellSize * 0.12, 0, Math.PI * 2);
    ctx.fillStyle = '#222'; ctx.fill();
  });
  // Freeze zones (blue tint)
  for (let r = 0; r < SIZE; r++) {
    for (let c = 0; c < SIZE; c++) {
      if (frozen[r][c]) {
        const {x, y} = gridToPixel(r, c);
        ctx.fillStyle = 'rgba(0,210,255,0.2)';
        ctx.fillRect(x - cellSize/2, y - cellSize/2, cellSize, cellSize);
        ctx.strokeStyle = 'rgba(0,210,255,0.5)';
        ctx.strokeRect(x - cellSize/2, y - cellSize/2, cellSize, cellSize);
      }
    }
  }
  // Pieces
  const pieceR = cellSize * 0.42;
  for (let r = 0; r < SIZE; r++) {
    for (let c = 0; c < SIZE; c++) {
      if (board[r][c] === EMPTY) continue;
      const {x, y} = gridToPixel(r, c);
      if (board[r][c] === BLACK) {
        // Black circle
        ctx.beginPath(); ctx.arc(x, y, pieceR, 0, Math.PI * 2);
        const grad = ctx.createRadialGradient(x - pieceR*0.3, y - pieceR*0.3, pieceR*0.1, x, y, pieceR);
        grad.addColorStop(0, '#555'); grad.addColorStop(1, '#111');
        ctx.fillStyle = grad; ctx.fill();
        ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.stroke();
      } else {
        // White square
        const half = pieceR * 0.85;
        ctx.fillStyle = '#f0f0f0';
        ctx.fillRect(x - half, y - half, half * 2, half * 2);
        ctx.strokeStyle = '#999'; ctx.lineWidth = 1.5;
        ctx.strokeRect(x - half, y - half, half * 2, half * 2);
        // Inner shine
        ctx.fillStyle = 'rgba(255,255,255,0.4)';
        ctx.fillRect(x - half + 2, y - half + 2, half, half * 0.5);
      }
    }
  }
  // Last move indicator
  if (moveHistory.length > 0) {
    const last = moveHistory[moveHistory.length - 1];
    const {x, y} = gridToPixel(last.r, last.c);
    ctx.strokeStyle = '#e94560';
    ctx.lineWidth = 2.5;
    if (last.player === BLACK) {
      ctx.beginPath(); ctx.arc(x, y, pieceR + 3, 0, Math.PI * 2); ctx.stroke();
    } else {
      const half = pieceR * 0.85 + 3;
      ctx.strokeRect(x - half, y - half, half * 2, half * 2);
    }
  }
  // Hover highlight
  if (hoverR >= 0 && hoverC >= 0 && !gameOver && activeSkill < 0 && board[hoverR][hoverC] === EMPTY && !frozen[hoverR][hoverC]) {
    const {x, y} = gridToPixel(hoverR, hoverC);
    ctx.globalAlpha = 0.4;
    if (currentPlayer === BLACK) {
      ctx.beginPath(); ctx.arc(x, y, pieceR, 0, Math.PI * 2);
      ctx.fillStyle = '#333'; ctx.fill();
    } else {
      const half = pieceR * 0.85;
      ctx.fillStyle = '#ccc';
      ctx.fillRect(x - half, y - half, half * 2, half * 2);
    }
    ctx.globalAlpha = 1;
  }
  // Skill-phase highlights
  if (activeSkill === 0 && skillPhase === 'removing') {
    // Highlight removable enemy pieces
    const enemy = currentPlayer === BLACK ? WHITE : BLACK;
    for (let r = 0; r < SIZE; r++) {
      for (let c = 0; c < SIZE; c++) {
        if (board[r][c] === enemy) {
          const {x, y} = gridToPixel(r, c);
          ctx.strokeStyle = '#ff0';
          ctx.lineWidth = 3;
          ctx.beginPath(); ctx.arc(x, y, pieceR + 5, 0, Math.PI * 2); ctx.stroke();
        }
      }
    }
  }
  if (activeSkill === 2 && skillPhase === 'choosing') {
    // Show hoverable freeze zone preview
    if (hoverR >= 0 && hoverC >= 0) {
      for (let dr = -2; dr <= 2; dr++) {
        for (let dc = -2; dc <= 2; dc++) {
          const nr = hoverR + dr, nc = hoverC + dc;
          if (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE) {
            const {x, y} = gridToPixel(nr, nc);
            ctx.fillStyle = 'rgba(0,210,255,0.25)';
            ctx.fillRect(x - cellSize/2, y - cellSize/2, cellSize, cellSize);
          }
        }
      }
    }
  }
}

// ============================================================
// WIN DETECTION ‚Äî Check for 5+ in a row
// ============================================================
function checkWin(r, c, player) {
  const dirs = [[0,1],[1,0],[1,1],[1,-1]];
  for (const [dr, dc] of dirs) {
    let count = 1;
    const cells = [[r,c]];
    for (let d = 1; d < SIZE; d++) {
      const nr = r + dr*d, nc = c + dc*d;
      if (nr < 0 || nr >= SIZE || nc < 0 || nc >= SIZE || board[nr][nc] !== player) break;
      count++; cells.push([nr, nc]);
    }
    for (let d = 1; d < SIZE; d++) {
      const nr = r - dr*d, nc = c - dc*d;
      if (nr < 0 || nr >= SIZE || nc < 0 || nc >= SIZE || board[nr][nc] !== player) break;
      count++; cells.push([nr, nc]);
    }
    if (count >= 5) return cells;
  }
  return null;
}

// Check if opponent has a threat (3+ in a row)
function hasThreat(player) {
  for (let r = 0; r < SIZE; r++) {
    for (let c = 0; c < SIZE; c++) {
      if (board[r][c] !== player) continue;
      const dirs = [[0,1],[1,0],[1,1],[1,-1]];
      for (const [dr, dc] of dirs) {
        let count = 1;
        for (let d = 1; d < 5; d++) {
          const nr = r + dr*d, nc = c + dc*d;
          if (nr < 0 || nr >= SIZE || nc < 0 || nc >= SIZE || board[nr][nc] !== player) break;
          count++;
        }
        if (count >= 3) return true;
      }
    }
  }
  return false;
}

// Highlight winning line
function highlightWin(cells) {
  ctx.strokeStyle = '#e94560';
  ctx.lineWidth = cellSize * 0.15;
  ctx.lineCap = 'round';
  ctx.globalAlpha = 0.7;
  // Sort cells along the line direction
  cells.sort((a, b) => a[0] - b[0] || a[1] - b[1]);
  const {x: x0, y: y0} = gridToPixel(cells[0][0], cells[0][1]);
  const {x: x1, y: y1} = gridToPixel(cells[cells.length-1][0], cells[cells.length-1][1]);
  ctx.beginPath(); ctx.moveTo(x0, y0); ctx.lineTo(x1, y1); ctx.stroke();
  ctx.globalAlpha = 1;
}

// ============================================================
// GAME LOGIC
// ============================================================
function placePiece(r, c) {
  if (gameOver || animating) return;
  if (board[r][c] !== EMPTY) return;
  if (frozen[r][c]) return;
  if (activeSkill >= 0) return; // Can't place during skill

  board[r][c] = currentPlayer;
  moveHistory.push({r, c, player: currentPlayer});
  playPlace();
  drawBoard();

  const winCells = checkWin(r, c, currentPlayer);
  if (winCells) {
    highlightWin(winCells);
    handleWin(currentPlayer);
    return;
  }

  // Decrement freeze zone turns
  tickFreezeZones();

  currentPlayer = currentPlayer === BLACK ? WHITE : BLACK;
  updateUI();
}

function tickFreezeZones() {
  freezeZones = freezeZones.filter(z => {
    z.turnsLeft--;
    if (z.turnsLeft <= 0) {
      // Unfreeze the 5x5 area
      for (let dr = -2; dr <= 2; dr++) {
        for (let dc = -2; dc <= 2; dc++) {
          const nr = z.r + dr, nc = z.c + dc;
          if (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE) {
            frozen[nr][nc] = false;
          }
        }
      }
      return false;
    }
    return true;
  });
}

function handleWin(winner) {
  gameOver = true;
  scores[winner]++;
  document.getElementById('black-score').textContent = scores[BLACK];
  document.getElementById('white-score').textContent = scores[WHITE];
  playWin();

  const name = winner === BLACK ? 'Black ‚óè' : 'White ‚óª';
  const overlay = document.getElementById('overlay');
  const content = document.getElementById('overlay-content');
  content.innerHTML = `
    <h2 style="color:var(--gold);animation:victory-dance 0.5s infinite">${name} WINS!</h2>
    <p style="color:var(--cyan)">ÊäÄËÉΩ‰∫îÂ≠êÊ£ã Ë¶ÅÁàÜÁÇ∏!</p>
    <button onclick="restartGame()">Play Again</button>
    <button onclick="shareScore()" id="share-btn-inner">Share #SkillGomoku</button>
  `;
  overlay.classList.add('active');
  spawnConfetti();
  playVictoryMelody();
}

function playVictoryMelody() {
  const notes = [523,659,784,880,1047,880,784,659,523,659,784,1047,1319,1047];
  notes.forEach((f,i) => setTimeout(() => playTone(f, 0.25, 'square', 0.07), i * 180));
}

function restartGame() {
  document.getElementById('overlay').classList.remove('active');
  initBoard();
  resetSkills();
  updateUI();
  drawBoard();
}

function updateUI() {
  const ti = document.getElementById('turn-indicator');
  if (currentPlayer === BLACK) {
    ti.className = 'black';
    ti.textContent = "Black's Turn ‚óè";
  } else {
    ti.className = 'white';
    ti.textContent = "White's Turn ‚óª";
  }
  // Update skill buttons
  const opponent = currentPlayer === BLACK ? WHITE : BLACK;
  const threatExists = hasThreat(opponent) || moveHistory.length > 0;
  for (let i = 0; i < 4; i++) {
    const btn = document.getElementById('skill-' + i);
    btn.className = 'skill-btn';
    if (skillUsed[currentPlayer][i]) {
      btn.classList.add('used');
    } else if (threatExists && !gameOver && activeSkill < 0) {
      btn.classList.add('ready');
    }
  }
  // Skill phase instructions
  if (activeSkill === 0 && skillPhase === 'removing') {
    ti.textContent = `Flying Sand: Remove ${removesLeft} more enemy pieces!`;
    ti.className = '';
    ti.style.color = '#ffd700';
  } else if (activeSkill === 2 && skillPhase === 'choosing') {
    ti.textContent = 'Still Water: Click to freeze a 5x5 zone!';
    ti.className = '';
    ti.style.color = '#00d2ff';
  } else {
    ti.style.color = '';
  }
}

// ============================================================
// SKILLS ‚Äî The four chaotic abilities
// ============================================================
function activateSkill(index) {
  if (gameOver || animating || activeSkill >= 0) return;
  if (skillUsed[currentPlayer][index]) return;
  const opponent = currentPlayer === BLACK ? WHITE : BLACK;
  const threatExists = hasThreat(opponent) || moveHistory.length > 0;
  if (!threatExists) return;

  skillUsed[currentPlayer][index] = true;
  activeSkill = index;
  playSkillSound();

  const names = ['È£ûÊ≤ôËµ∞Áü≥', 'ÂäõÊãîÂ±±ÂÖÆ', 'ÈùôÂ¶ÇÊ≠¢Ê∞¥', 'Êó∂ÂÖâÂÄíÊµÅ'];
  const enNames = ['Flying Sand & Rolling Stones!', 'Pulling Up Mountains!', 'Still as Still Water!', 'Time Reversal!'];
  const colors = ['#ffd700', '#e94560', '#00d2ff', '#0f0'];

  showSkillText(names[index], colors[index]);
  chant(names[index]);

  switch(index) {
    case 0: executeSkill0(); break;
    case 1: executeSkill1(); break;
    case 2: executeSkill2(); break;
    case 3: executeSkill3(); break;
  }
}

function showSkillText(text, color) {
  const el = document.getElementById('skill-text');
  const overlay = document.getElementById('skill-overlay');
  el.textContent = text;
  el.style.color = color;
  overlay.classList.add('active');
  // Reset animation
  el.style.animation = 'none';
  void el.offsetWidth;
  el.style.animation = 'skillFlash 1.5s forwards';
  setTimeout(() => overlay.classList.remove('active'), 1600);
}

// --- SKILL 0: Flying Sand and Rolling Stones ---
function executeSkill0() {
  animating = true;
  // Wind particles animation
  spawnWindParticles();
  // Shake the board
  const wrap = document.getElementById('canvas-wrap');
  wrap.style.animation = 'shake 0.8s';
  setTimeout(() => {
    wrap.style.animation = '';
    animating = false;
    skillPhase = 'removing';
    removesLeft = 5;
    // Count available enemy pieces
    const enemy = currentPlayer === BLACK ? WHITE : BLACK;
    let enemyCount = 0;
    for (let r = 0; r < SIZE; r++)
      for (let c = 0; c < SIZE; c++)
        if (board[r][c] === enemy) enemyCount++;
    removesLeft = Math.min(5, enemyCount);
    if (removesLeft === 0) {
      finishSkill();
    }
    updateUI();
    drawBoard();
  }, 1000);
}

function handleSkill0Click(r, c) {
  const enemy = currentPlayer === BLACK ? WHITE : BLACK;
  if (board[r][c] !== enemy) return;
  board[r][c] = EMPTY;
  removesLeft--;
  // Splash effect
  spawnSplash(r, c);
  playTone(200 + Math.random() * 400, 0.15, 'sine', 0.1);
  drawBoard();
  if (removesLeft <= 0) {
    finishSkill();
  }
  updateUI();
}

// --- SKILL 1: Pulling Up Mountains ---
function executeSkill1() {
  animating = true;
  // Epic shake + crack
  const wrap = document.getElementById('canvas-wrap');
  wrap.style.animation = 'shake 1.2s';
  // Hat emoji overlay
  spawnHatEmojis();
  setTimeout(() => {
    // Flip the board randomly (vertical or horizontal)
    const flipType = Math.random() < 0.5 ? 'vertical' : 'horizontal';
    const newBoard = Array.from({length: SIZE}, () => Array(SIZE).fill(EMPTY));
    for (let r = 0; r < SIZE; r++) {
      for (let c = 0; c < SIZE; c++) {
        if (flipType === 'vertical') {
          newBoard[SIZE - 1 - r][c] = board[r][c];
        } else {
          newBoard[r][SIZE - 1 - c] = board[r][c];
        }
      }
    }
    board = newBoard;
    // Also flip frozen zones
    const newFrozen = Array.from({length: SIZE}, () => Array(SIZE).fill(false));
    for (let r = 0; r < SIZE; r++) {
      for (let c = 0; c < SIZE; c++) {
        if (flipType === 'vertical') {
          newFrozen[SIZE - 1 - r][c] = frozen[r][c];
        } else {
          newFrozen[r][SIZE - 1 - c] = frozen[r][c];
        }
      }
    }
    frozen = newFrozen;

    wrap.style.animation = '';
    animating = false;
    finishSkill();
    drawBoard();
  }, 1300);
}

// --- SKILL 2: Still as Still Water ---
function executeSkill2() {
  animating = true;
  // Ripple wave from center
  spawnRipple();
  setTimeout(() => {
    animating = false;
    skillPhase = 'choosing';
    updateUI();
    drawBoard();
  }, 1000);
}

function handleSkill2Click(r, c) {
  // Freeze a 5x5 area around (r,c) for 2 turns
  freezeZones.push({r, c, turnsLeft: 4}); // 4 half-turns = 2 full turns per player
  for (let dr = -2; dr <= 2; dr++) {
    for (let dc = -2; dc <= 2; dc++) {
      const nr = r + dr, nc = c + dc;
      if (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE) {
        frozen[nr][nc] = true;
      }
    }
  }
  playTone(800, 0.3, 'sine', 0.1);
  finishSkill();
  drawBoard();
}

// --- SKILL 3: Time Reversal ---
function executeSkill3() {
  animating = true;
  // Board rotation animation
  const wrap = document.getElementById('canvas-wrap');
  wrap.style.transition = 'transform 1s';
  wrap.style.transform = 'rotate(180deg)';

  setTimeout(() => {
    // Remove opponent's last 3 moves
    const opponent = currentPlayer === BLACK ? WHITE : BLACK;
    let removed = 0;
    for (let i = moveHistory.length - 1; i >= 0 && removed < 3; i--) {
      if (moveHistory[i].player === opponent) {
        board[moveHistory[i].r][moveHistory[i].c] = EMPTY;
        moveHistory.splice(i, 1);
        removed++;
      }
    }

    wrap.style.transition = 'transform 0.5s';
    wrap.style.transform = 'rotate(0deg)';

    setTimeout(() => {
      wrap.style.transition = '';
      wrap.style.transform = '';
      animating = false;
      finishSkill();
      drawBoard();
    }, 600);
  }, 1100);
}

function finishSkill() {
  activeSkill = -1;
  skillPhase = '';
  removesLeft = 0;
  // Skill counts as a turn
  tickFreezeZones();
  currentPlayer = currentPlayer === BLACK ? WHITE : BLACK;
  updateUI();
}

// ============================================================
// PARTICLE EFFECTS
// ============================================================
let particles = [];

function spawnConfetti() {
  const colors = ['#e94560','#ffd700','#00d2ff','#0f0','#ff6b6b','#fff'];
  for (let i = 0; i < 60; i++) {
    const el = document.createElement('div');
    el.className = 'confetti';
    el.style.left = Math.random() * 100 + 'vw';
    el.style.background = colors[Math.floor(Math.random() * colors.length)];
    el.style.width = (5 + Math.random() * 10) + 'px';
    el.style.height = (5 + Math.random() * 10) + 'px';
    el.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
    el.style.animationDuration = (2 + Math.random() * 2) + 's';
    el.style.animationDelay = Math.random() * 1.5 + 's';
    document.body.appendChild(el);
    setTimeout(() => el.remove(), 5000);
  }
}

function spawnWindParticles() {
  const pCtx2 = pCtx;
  const pw = pCanvas.width, ph = pCanvas.height;
  let windParticles = [];
  for (let i = 0; i < 50; i++) {
    windParticles.push({
      x: -20, y: Math.random() * ph,
      vx: 8 + Math.random() * 12, vy: -2 + Math.random() * 4,
      size: 2 + Math.random() * 5,
      color: `hsl(${40 + Math.random()*20}, 80%, ${50 + Math.random()*30}%)`,
      life: 0
    });
  }
  let frame = 0;
  function animWind() {
    pCtx2.clearRect(0, 0, pw, ph);
    windParticles.forEach(p => {
      p.x += p.vx; p.y += p.vy; p.life++;
      pCtx2.globalAlpha = Math.max(0, 1 - p.life / 60);
      pCtx2.fillStyle = p.color;
      pCtx2.beginPath();
      pCtx2.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      pCtx2.fill();
    });
    pCtx2.globalAlpha = 1;
    frame++;
    if (frame < 60) requestAnimationFrame(animWind);
    else pCtx2.clearRect(0, 0, pw, ph);
  }
  animWind();
}

function spawnSplash(r, c) {
  const rect = canvasEl.getBoundingClientRect();
  const ratio = window.devicePixelRatio || 1;
  const {x, y} = gridToPixel(r, c);
  const sx = rect.left + x / ratio;
  const sy = rect.top + y / ratio;
  for (let i = 0; i < 12; i++) {
    const el = document.createElement('div');
    el.style.cssText = `position:fixed;left:${sx}px;top:${sy}px;width:6px;height:6px;
      background:#4af;border-radius:50%;z-index:700;pointer-events:none;
      transition:all 0.6s ease-out;opacity:1;`;
    document.body.appendChild(el);
    const angle = (Math.PI * 2 / 12) * i;
    const dist = 30 + Math.random() * 40;
    requestAnimationFrame(() => {
      el.style.transform = `translate(${Math.cos(angle)*dist}px, ${Math.sin(angle)*dist}px)`;
      el.style.opacity = '0';
    });
    setTimeout(() => el.remove(), 700);
  }
}

function spawnHatEmojis() {
  for (let i = 0; i < 8; i++) {
    const el = document.createElement('div');
    el.textContent = ['üé©','üí•','üèîÔ∏è','üëä'][i % 4];
    el.style.cssText = `position:fixed;font-size:${30+Math.random()*30}px;z-index:700;
      pointer-events:none;left:${10+Math.random()*80}vw;top:${10+Math.random()*60}vh;
      transition:all 1.2s ease-out;opacity:1;`;
    document.body.appendChild(el);
    requestAnimationFrame(() => {
      el.style.transform = `translateY(${-50-Math.random()*100}px) rotate(${Math.random()*360}deg)`;
      el.style.opacity = '0';
    });
    setTimeout(() => el.remove(), 1500);
  }
}

function spawnRipple() {
  const rect = canvasEl.getBoundingClientRect();
  const cx = rect.left + rect.width / 2;
  const cy = rect.top + rect.height / 2;
  for (let i = 0; i < 4; i++) {
    setTimeout(() => {
      const el = document.createElement('div');
      el.style.cssText = `position:fixed;left:${cx}px;top:${cy}px;width:40px;height:40px;
        border:3px solid rgba(0,210,255,0.6);border-radius:50%;z-index:700;
        pointer-events:none;transform:translate(-50%,-50%);animation:ripple 1s ease-out forwards;`;
      document.body.appendChild(el);
      setTimeout(() => el.remove(), 1100);
    }, i * 200);
  }
}

// ============================================================
// INPUT HANDLING
// ============================================================
function setupInput() {
  canvasEl.addEventListener('mousemove', (e) => {
    const rect = canvasEl.getBoundingClientRect();
    const pos = pixelToGrid(e.clientX - rect.left, e.clientY - rect.top);
    if (pos) { hoverR = pos.r; hoverC = pos.c; }
    else { hoverR = -1; hoverC = -1; }
    drawBoard();
  });

  canvasEl.addEventListener('mouseleave', () => {
    hoverR = -1; hoverC = -1;
    drawBoard();
  });

  canvasEl.addEventListener('click', handleClick);
  canvasEl.addEventListener('touchend', (e) => {
    e.preventDefault();
    const touch = e.changedTouches[0];
    const rect = canvasEl.getBoundingClientRect();
    const pos = pixelToGrid(touch.clientX - rect.left, touch.clientY - rect.top);
    if (pos) processClick(pos.r, pos.c);
  });
}

function handleClick(e) {
  const rect = canvasEl.getBoundingClientRect();
  const pos = pixelToGrid(e.clientX - rect.left, e.clientY - rect.top);
  if (pos) processClick(pos.r, pos.c);
}

function processClick(r, c) {
  if (gameOver || animating) return;

  // Skill sub-phases
  if (activeSkill === 0 && skillPhase === 'removing') {
    handleSkill0Click(r, c);
    return;
  }
  if (activeSkill === 2 && skillPhase === 'choosing') {
    handleSkill2Click(r, c);
    return;
  }
  if (activeSkill >= 0) return;

  placePiece(r, c);
}

// ============================================================
// SHARE
// ============================================================
function shareScore() {
  const text = `ÊäÄËÉΩ‰∫îÂ≠êÊ£ã Skill Gomoku!\nBlack ${scores[BLACK]} - ${scores[WHITE]} White\n#SkillGomoku #ÊäÄËÉΩ‰∫îÂ≠êÊ£ã`;
  if (navigator.share) {
    navigator.share({title: 'Skill Gomoku', text});
  } else {
    const url = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}`;
    window.open(url, '_blank');
  }
}

// ============================================================
// START / INIT
// ============================================================
function startGame() {
  initAudio();
  stopTitleMelody();
  document.getElementById('title-screen').classList.add('hidden');
  document.getElementById('game-container').classList.add('active');
  setTimeout(() => document.getElementById('title-screen').style.display = 'none', 800);
  initBoard();
  resetSkills();
  setupCanvas();
  setupInput();
  updateUI();
  drawBoard();
}

// Title screen melody
window.addEventListener('click', function firstClick() {
  initAudio();
  playTitleMelody();
  window.removeEventListener('click', firstClick);
}, {once: true});

// Keyboard restart
document.addEventListener('keydown', (e) => {
  if (e.key === 'r' || e.key === 'R') restartGame();
});
</script>
</body>
</html>
